
#if CONFIG_HAL_BOARD == HAL_BOARD_REVOMINI

#include "DataFlash.h"

extern AP_HAL::HAL& hal;

/*
 * TODO DRIVER NEED TO BE FIXED !!!
 */

// the last page holds the log format in first 4 bytes. Please change
// this if (and only if!) the low level format changes
#define DF_LOGGING_FORMAT    0x28122013

#define dfEE_PAGESIZE   256
__IO uint8_t   dfEEDataNum;

// *** DATAFLASH PUBLIC FUNCTIONS ***
void DataFlash_Block::StartWrite(uint16_t PageAdr)
{
    df_BufferIdx  = 0;
    df_BufferNum  = 0;
    df_PageAdr    = PageAdr;
    WaitReady();
}

void DataFlash_Block::FinishWrite(void)
{
    df_PageAdr++;
    // If we reach the end of the memory, start from the begining
    if (df_PageAdr > df_NumPages){
	df_PageAdr--;
      //  df_PageAdr = 1;
	log_write_started = false; // DF is full Stop loging
    }

    df_BufferIdx = 0;
}

void DataFlash_Block::WriteBlock(const void *pBuffer, uint16_t size)
{
    if (!CardInserted() || !log_write_started) {
        return;
    }
    uint32_t AddressToWrite = df_PageAdr << 8;

    while (size > 0) {
	uint16_t n = df_PageSize - df_BufferIdx;
	if (n > size) {
	    n = size;
	}

	if (df_BufferIdx == 0) {
	    // if we are at the start of a page we need to insert a
	    // page header
	    if (n > df_PageSize - sizeof(struct PageHeader)) {
		n = df_PageSize - sizeof(struct PageHeader);
	    }
	    struct PageHeader ph = { df_FileNumber, df_FilePage };
    //	BlockWrite(df_BufferIdx + AddressToWrite, &ph, sizeof(ph), pBuffer, n);
	    BlockWrite(AddressToWrite, &ph, sizeof(ph), pBuffer, n); // write PageHeader+data
	    df_BufferIdx += n + sizeof(ph);
	 } else {
	    BlockWrite(df_BufferIdx + AddressToWrite, NULL, 0, pBuffer, n);
	    df_BufferIdx += n;
	 }

	size -= n;
	pBuffer = (const void *)(n + (uintptr_t)pBuffer);

	if (df_BufferIdx == df_PageSize) {
	    FinishWrite();
	    df_FilePage++;
	}
    }
}


// Get the last page written to
uint16_t DataFlash_Block::GetWritePage()
{
    return df_PageAdr;
}

// Get the last page read
uint16_t DataFlash_Block::GetPage()
{
    return df_Read_PageAdr;
}

void DataFlash_Block::StartRead(uint16_t PageAdr)
{
    df_Read_PageAdr   = PageAdr;

    WaitReady();

    // We are starting a new page - read FileNumber and FilePage
    struct PageHeader ph;
    BlockRead(df_Read_PageAdr << 8, &ph, sizeof(ph));
    df_FileNumber = ph.FileNumber;
    df_FilePage   = ph.FilePage;
    df_Read_BufferIdx = sizeof(ph);
}

void DataFlash_Block::ReadBlock(void *pBuffer, uint16_t size)
{
    while (size > 0) {
        uint16_t n = df_PageSize - df_Read_BufferIdx;
        if (n > size) {
            n = size;
        }

        WaitReady();

        BlockRead(df_Read_BufferIdx + (df_Read_PageAdr << 8), pBuffer, n);
        size -= n;
        pBuffer = (void *)(n + (uintptr_t)pBuffer);

        df_Read_BufferIdx += n;

        if (df_Read_BufferIdx == df_PageSize) { // df_PageSize=256 bytes
            df_Read_PageAdr++;
            if (df_Read_PageAdr > df_NumPages) {
                df_Read_PageAdr = 1;
            }
            // We are starting a new page - read FileNumber and FilePage
            struct PageHeader ph;
            BlockRead(df_Read_PageAdr * 256, &ph, sizeof(ph));
            df_FileNumber = ph.FileNumber;
            df_FilePage   = ph.FilePage;

            df_Read_BufferIdx = sizeof(ph);
        }
    }
}

void DataFlash_Block::SetFileNumber(uint16_t FileNumber)
{
    df_FileNumber = FileNumber;
    df_FilePage = 1;
}

uint16_t DataFlash_Block::GetFileNumber()
{
    return df_FileNumber;
}

uint16_t DataFlash_Block::GetFilePage()
{
    return df_FilePage;
}

#define LED_GRN (*((unsigned long int *) 0x42408294)) // PB5
#define LED_YLW (*((unsigned long int *) 0x42408298)) // PB6 // not instaled
#define LED_RED (*((unsigned long int *) 0x42408290)) // PB4
#include <delay.h>

void DataFlash_Block::EraseAll()
{
    static uint16_t _erase_led = 0;
    LED_GRN = 0;
    LED_RED = 1;
    for (uint16_t sector = 0; sector < 30; sector++) { // Erase 30 pages * 256 bytes (2 sectors reserved for parameters)
	hal.console->printf("Erase Page: %u", sector);
	Flash_Jedec_EraseSector(sector << 16);

	 if (_erase_led == 1){
	     LED_RED=0;
	     LED_GRN = 1;
	     _erase_led=0;
	     } else{
	     LED_RED=1;
	     LED_GRN = 0;
             _erase_led=1;
	     }

    }

    LED_RED=1;
    LED_GRN = 1;

    // write the logging format in the last page
    hal.scheduler->delay(100);
    StartWrite(0); // Set Write Page to 0
    uint32_t version = DF_LOGGING_FORMAT;
    log_write_started = true;
    df_FileNumber = 1;
    df_FilePage = 1;
    WriteBlock(&version, sizeof(version));
    log_write_started = false;
    FinishWrite();
    hal.scheduler->delay(100);
}

/*
 *  we need to erase if the logging format has changed
 */
bool DataFlash_Block::NeedErase(void)
{
    uint32_t version = 0;
    StartRead(0);  // Firs Page
    ReadBlock(&version, sizeof(version));
    StartRead(1);
    return version != DF_LOGGING_FORMAT;
}



int16_t DataFlash_Block::get_log_data_raw(uint16_t log_num, uint16_t page, uint32_t offset, uint16_t len, uint8_t *data)
{
    uint16_t data_page_size = df_PageSize - sizeof(struct PageHeader);

    if (offset >= data_page_size) {
        page += offset / data_page_size;
        offset = offset % data_page_size;
        if (page > df_NumPages) {
            // pages are one based, not zero
            page = 1 + page - df_NumPages;
        }
    }
    if (log_write_started || df_Read_PageAdr != page) {
        StartRead(page);
    }

    df_Read_BufferIdx = offset + sizeof(struct PageHeader);
    ReadBlock(data, len);

    return (int16_t)len;
}

/**
  get data from a log, accounting for adding FMT headers
 */

int16_t DataFlash_Block::get_log_data(uint16_t log_num, uint16_t page, uint32_t offset, uint16_t len, uint8_t *data)
{
    if (offset == 0) {
        uint8_t header[3];
        get_log_data_raw(log_num, page, 0, 3, header);
        adding_fmt_headers = (header[0] != HEAD_BYTE1 || header[1] != HEAD_BYTE2 || header[2] != LOG_FORMAT_MSG);
    }
    uint16_t ret = 0;

    if (adding_fmt_headers) {
        // the log doesn't start with a FMT message, we need to add
        // them
        const uint16_t fmt_header_size = _num_types * sizeof(struct log_Format);
        while (offset < fmt_header_size && len > 0) {
            struct log_Format pkt;
            uint8_t t = offset / sizeof(pkt);
            uint8_t ofs = offset % sizeof(pkt);
            Log_Fill_Format(&_structures[t], pkt);
            uint8_t n = sizeof(pkt) - ofs;
            if (n > len) {
                n = len;
            }
            memcpy(data, ofs + (uint8_t *)&pkt, n);
            data += n;
            offset += n;
            len -= n;
            ret += n;
        }
        offset -= fmt_header_size;
    }

    if (len > 0) {
        ret += get_log_data_raw(log_num, page, offset, len, data);
    }

    return ret;
}


/* END REVOMINI DATA FLASH */

